import streamlit as st
import mediapipe as mp
import cv2
import numpy as np
from PIL import Image, ImageOps
from ultralytics import YOLO
import math

# ==========================================
# [Module 05] Database
# ==========================================
MATERIAL_DB = {
    "knit": {"thickness": 5.0, "stretch_factor": 0.95, "desc": "ë‹ˆíŠ¸/ìŠ¤ì›¨í„° (ì‹ ì¶•ì„± ë†’ìŒ)"},
    "cotton": {"thickness": 2.0, "stretch_factor": 0.98, "desc": "ë©´ í‹°ì…”ì¸ /ì…”ì¸  (ì¼ë°˜)"},
    "denim": {"thickness": 8.0, "stretch_factor": 1.02, "desc": "ë°ë‹˜/ì²­ìì¼“ (ë¹³ë¹³í•¨)"},
    "silk": {"thickness": 1.0, "stretch_factor": 1.01, "desc": "ì‹¤í¬/ë¸”ë¼ìš°ìŠ¤ (íë¥´ëŠ” í•)"}
}

class Module01_ReferenceObject:
    """
    [Smart-Lock Logic]
    1. ëª¸í†µ ì¤‘ì•™ì— ê²€ìƒ‰ ë°•ìŠ¤(ROI)ë¥¼ ì¹©ë‹ˆë‹¤.
    2. ê·¸ ì•ˆì—ì„œ í°ìƒ‰ ë©ì–´ë¦¬ë¥¼ ì°¾ë˜, 'ë„ˆë¬´ í° ë©ì–´ë¦¬(ì˜·)'ëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤.
    """
    def get_scale_factor(self, image_np, pose_landmarks):
        h, w, _ = image_np.shape
        
        # 1. ROI ì„¤ì • (Center-Out)
        if pose_landmarks:
            lm = pose_landmarks.landmark
            center_x = (lm[11].x + lm[12].x + lm[23].x + lm[24].x) / 4.0 * w
            center_y = (lm[11].y + lm[12].y + lm[23].y + lm[24].y) / 4.0 * h
            
            shoulder_width = abs(lm[11].x - lm[12].x) * w
            hip_width = abs(lm[23].x - lm[24].x) * w
            torso_width = max(shoulder_width, hip_width)
            torso_height = abs(lm[11].y - lm[23].y) * h 
            
            # ë°•ìŠ¤ í¬ê¸°
            box_w = torso_width * 1.3
            box_h = torso_height * 1.2
            
            roi_x1 = int(max(0, center_x - (box_w / 2)))
            roi_x2 = int(min(w, center_x + (box_w / 2)))
            roi_y1 = int(max(0, center_y - (box_h / 2)))
            roi_y2 = int(min(h, center_y + (box_h / 2)))
            
            roi_box = (roi_x1, roi_y1, roi_x2, roi_y2)
            roi_area = (roi_x2 - roi_x1) * (roi_y2 - roi_y1)
        else:
            roi_box = (0, 0, w, h)
            roi_area = w * h

        # 2. ì´ë¯¸ì§€ ì „ì²˜ë¦¬
        hsv = cv2.cvtColor(image_np, cv2.COLOR_BGR2HSV)
        # í°ìƒ‰ ë²”ìœ„ (ì¡°ê¸ˆ ë” ì—„ê²©í•˜ê²Œ ì¡°ì •)
        lower_white = np.array([0, 0, 170]) 
        upper_white = np.array([180, 40, 255])
        mask = cv2.inRange(hsv, lower_white, upper_white)
        
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
        
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        scale_factor = None
        ref_box = None
        
        # 3. [Size Filter] ì˜·(Shirt) ê±°ë¥´ê³  ì¢…ì´(Paper)ë§Œ ì°¾ê¸°
        valid_contours = []
        
        for c in contours:
            area = cv2.contourArea(c)
            # ì¡°ê±´ 1: ë„ˆë¬´ ì‘ìœ¼ë©´(ë…¸ì´ì¦ˆ) íƒˆë½
            if area < 1000: continue 
            
            # ì¡°ê±´ 2: "ë„ˆë¬´ í¬ë©´(ì˜·)" íƒˆë½ (ROI ë©´ì ì˜ 60% ì´ìƒì´ë©´ ì˜·ìœ¼ë¡œ ê°„ì£¼)
            if area > (roi_area * 0.6): continue

            # ì¡°ê±´ 3: ì¤‘ì‹¬ì ì´ ROI ë°•ìŠ¤ ì•ˆì— ìˆì–´ì•¼ í•¨
            M = cv2.moments(c)
            if M["m00"] != 0:
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])
                if (roi_box[0] <= cX <= roi_box[2]) and (roi_box[1] <= cY <= roi_box[3]):
                    valid_contours.append(c)

        if valid_contours:
            # ë‚¨ì€ í›„ë³´(ì ë‹¹í•œ í¬ê¸°ì˜ í°ìƒ‰) ì¤‘ ê°€ì¥ í° ë†ˆì´ A4
            largest_contour = max(valid_contours, key=cv2.contourArea)
            
            rect = cv2.minAreaRect(largest_contour)
            box = cv2.boxPoints(rect)
            box = np.int32(box) 
            ref_box = box
            
            w_rect, h_rect = rect[1]
            if w_rect > 0 and h_rect > 0:
                short_side = min(w_rect, h_rect)
                mm_per_pixel = 210.0 / short_side
                scale_factor = mm_per_pixel
                
        # ë””ë²„ê¹… ì´ë¯¸ì§€ (ë°•ìŠ¤ ê·¸ë¦¬ê¸°)
        debug_img = image_np.copy()
        cv2.rectangle(debug_img, (roi_box[0], roi_box[1]), (roi_box[2], roi_box[3]), (0, 255, 0), 2)
        
        return scale_factor, ref_box, debug_img

class FormFoundryEngine:
    def __init__(self):
        self.scaler = Module01_ReferenceObject()
        self.mp_pose = mp.solutions.pose
        self.pose = self.mp_pose.Pose(static_image_mode=True, model_complexity=2, enable_segmentation=True)
        self.mp_drawing = mp.solutions.drawing_utils
        self.yolo_model = YOLO("yolov8n-cls.pt") 

    def calculate_distance(self, p1, p2, img_w, img_h):
        x1, y1 = p1.x * img_w, p1.y * img_h
        x2, y2 = p2.x * img_w, p2.y * img_h
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

    def process(self, image_file, manual_scale):
        original_image = Image.open(image_file)
        image = ImageOps.exif_transpose(original_image)
        image_np = np.array(image.convert('RGB'))
        img_h, img_w, _ = image_np.shape
        annotated_image = image_np.copy()

        # 1. Pose Estimation
        results = self.pose.process(image_np)
        
        if not results.pose_landmarks:
            return None, "ì‚¬ëŒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            
        lm = results.pose_landmarks.landmark

        # 2. [Module 01] Smart-Lock PnP
        auto_scale, ref_box, debug_img = self.scaler.get_scale_factor(image_np, results.pose_landmarks)
        
        if auto_scale:
            final_scale = auto_scale
            is_calibrated = True
            if ref_box is not None:
                # A4 ë°œê²¬ ì‹œ íŒŒë€ìƒ‰ìœ¼ë¡œ ì¹ í•˜ê¸°
                cv2.drawContours(annotated_image, [ref_box], 0, (255, 0, 0), 3) 
                top_point = tuple(ref_box[1])
                cv2.putText(annotated_image, f"A4: {final_scale:.3f}", top_point, cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)
        else:
            final_scale = manual_scale 
            is_calibrated = False

        # 3. YOLO Inference
        yolo_results = self.yolo_model(image)
        avg_brightness = np.mean(image_np)
        if avg_brightness < 80: detected_material = "denim"
        elif avg_brightness < 120: detected_material = "knit"
        elif avg_brightness < 180: detected_material = "cotton"
        else: detected_material = "silk"
        mat_info = MATERIAL_DB[detected_material]

        # 4. Measurements
        px_shoulder = self.calculate_distance(lm[11], lm[12], img_w, img_h)
        
        left_arm = self.calculate_distance(lm[11], lm[13], img_w, img_h) + \
                   self.calculate_distance(lm[13], lm[15], img_w, img_h)
        right_arm = self.calculate_distance(lm[12], lm[14], img_w, img_h) + \
                    self.calculate_distance(lm[14], lm[16], img_w, img_h)
        px_arm = (left_arm + right_arm) / 2
        
        left_leg = self.calculate_distance(lm[23], lm[25], img_w, img_h) + \
                   self.calculate_distance(lm[25], lm[27], img_w, img_h)
        right_leg = self.calculate_distance(lm[24], lm[26], img_w, img_h) + \
                    self.calculate_distance(lm[26], lm[28], img_w, img_h)
        px_leg = (left_leg + right_leg) / 2

        mid_ankle_x = (lm[27].x + lm[28].x) / 2
        mid_ankle_y = (lm[27].y + lm[28].y) / 2
        eye_y = (lm[2].y + lm[5].y) / 2
        nose_y = lm[0].y
        head_top_y = eye_y - (nose_y - eye_y) * 4.0 
        
        p_head_top = type('obj', (object,), {'x': (lm[0].x), 'y': head_top_y})
        p_mid_ankle = type('obj', (object,), {'x': mid_ankle_x, 'y': mid_ankle_y})
        px_full_height = self.calculate_distance(p_head_top, p_mid_ankle, img_w, img_h)

        measurements = {
            "Height (Est.)": px_full_height * final_scale,
            "Shoulder Width": px_shoulder * final_scale,
            "Arm Length": px_arm * final_scale, 
            "Leg Length": px_leg * final_scale,
        }

        final_shoulder = (measurements["Shoulder Width"] * mat_info['stretch_factor']) - (mat_info['thickness'] * 2)

        # [í•„ìˆ˜] ë¼ˆëŒ€ ê·¸ë¦¬ê¸° (ê°€ì¥ ë§ˆì§€ë§‰ì— ê·¸ë ¤ì•¼ í™”ë©´ì— ë³´ì„)
        self.mp_drawing.draw_landmarks(
            annotated_image, 
            results.pose_landmarks, 
            self.mp_pose.POSE_CONNECTIONS,
            mp.solutions.drawing_styles.get_default_pose_landmarks_style()
        )

        return {
            "image": annotated_image, # ë¼ˆëŒ€ê°€ ê·¸ë ¤ì§„ ìµœì¢… ì´ë¯¸ì§€
            "debug_img": debug_img,   # ë°•ìŠ¤ë§Œ ìˆëŠ” ë””ë²„ê·¸ìš© ì´ë¯¸ì§€
            "measurements": measurements,
            "final_shoulder": final_shoulder,
            "mat_info": mat_info,
            "detected_material": detected_material,
            "is_calibrated": is_calibrated,
            "final_scale": final_scale
        }, None

# ==========================================
# UI Layout
# ==========================================
st.set_page_config(layout="wide", page_title="FormFoundry AI")
st.title("ğŸ—ï¸ Form Foundry AI : Integrated MVP")

st.sidebar.header("âš™ï¸ Calibration")
manual_scale = st.sidebar.slider("Manual Scale Backup", 0.3, 1.5, 0.75, 0.001)

engine = FormFoundryEngine()
uploaded_file = st.file_uploader("Upload Photo", type=['jpg', 'png', 'jpeg'])

if uploaded_file is not None:
    result, error = engine.process(uploaded_file, manual_scale)
    
    if error:
        st.error(error)
    else:
        if result['is_calibrated']:
            st.sidebar.success(f"âœ… A4 Detected (Smart Mode)")
        else:
            st.sidebar.error("âŒ A4 Not Detected")
            st.sidebar.warning("ì˜·ê³¼ ì¢…ì´ê°€ êµ¬ë¶„ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¢…ì´ í…Œë‘ë¦¬ì— ì„ ì„ ê·¸ì–´ì£¼ì„¸ìš”.")

        col1, col2 = st.columns([1, 1])
        with col1:
            st.subheader("ğŸ“¸ Detection View")
            # [ìˆ˜ì •ë¨] ì´ì œ ë¼ˆëŒ€ê°€ ê·¸ë ¤ì§„ 'image'ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
            st.image(result['image'], caption="Skeleton + A4 Detection", use_container_width=True)
            
            with st.expander("ğŸ› ï¸ Debug: Search Zone"):
                st.image(result['debug_img'], caption="AI Search Area (Green Box)", use_container_width=True)

        with col2:
            st.subheader("ğŸ“‹ Final Specs")
            meas = result['measurements']
            
            # í‚¤ê°€ 730mm ì²˜ëŸ¼ ë§ë„ ì•ˆ ë˜ê²Œ ë‚˜ì˜¤ë©´ ê²½ê³ 
            if meas['Height (Est.)'] < 1000:
                st.error(f"âš ï¸ ì¸¡ì • ì˜¤ë¥˜: í‚¤ê°€ {meas['Height (Est.)']:.1f}mmë¡œ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤.")
                st.warning("ì›ì¸: í°ìƒ‰ ì˜·ì„ A4 ìš©ì§€ë¡œ ì°©ê°í–ˆìŠµë‹ˆë‹¤. ì˜·ë³´ë‹¤ ë” í•˜ì–€ ì¢…ì´ë¥¼ ì“°ê±°ë‚˜ í…Œë‘ë¦¬ë¥¼ ê·¸ë ¤ì£¼ì„¸ìš”.")
            else:
                st.metric("Total Height (Est.)", f"{meas['Height (Est.)']:.1f} mm")
            
            c1, c2 = st.columns(2)
            c1.metric("Shoulder", f"{meas['Shoulder Width']:.1f} mm")
            c2.metric("Arm", f"{meas['Arm Length']:.1f} mm") 
            
            st.metric("Leg", f"{meas['Leg Length']:.1f} mm")
            
            st.divider()
            st.success(f"Final Pattern Shoulder: {result['final_shoulder']:.1f} mm")
